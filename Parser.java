import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*ClassFile {
	u4             magic;
	u2             minor_version;
	u2             major_version;
	u2             constant_pool_count;
	cp_info        constant_pool[constant_pool_count-1];
	u2             access_flags;
	u2             this_class;
	u2             super_class;
	u2             interfaces_count;
	u2             interfaces[interfaces_count];
	u2             fields_count;
	field_info     fields[fields_count];
	u2             methods_count;
	method_info    methods[methods_count];
	u2             attributes_count;
	attribute_info attributes[attributes_count];
}*/

public class Parser {

	private int count = 0;
	List<ConstantPoolRecord> constants = new ArrayList<>();

	public static void main(String[] args) {
		if (args.length == 0) {
			System.out.println("Use [/path/file.class] as first argument");
			System.exit(0);
		}
		Parser parser = new Parser();
		parser.process(args[0]);
	}

	private void process(String fileName) {
		File file = new File(fileName);
		try (FileInputStream fis = new FileInputStream(file)) {
			DataInputStream dis = new DataInputStream(fis);
			count = Magic.BYTES;
			Magic.getMagic(dis);
			getU2(dis, "Minor version");
			getU2(dis, "Major version");
			int constantPoolCount = getU2(dis, "Constant pool count");
			readConstantPool(dis, constantPoolCount);
			getU2(dis, "Access flags");
			getU2(dis, "This class", true);
			getU2(dis, "Super class", true);
			int interfacesCount = getU2(dis, "Interfaces count");
			readInterfaces(dis, interfacesCount);
			int fieldsCount = getU2(dis, "Fields count");
			readFields(dis, fieldsCount);
			int methodsCount = getU2(dis, "Methods count");
			readMethods(dis, methodsCount);
			int attributesCount = getU2(dis, "Attributes count");
			readAttributes(dis, attributesCount);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void readInterfaces(DataInputStream dis, int interfacesCount) throws IOException {
		for (int i = 0; i < interfacesCount; i++) {
			getU2(dis, "", true);
		}
	}

	/**
	 * <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.5">4.5. Fields</a>
	 */
	private void readFields(DataInputStream dis, int fieldsCount) throws IOException {
		for (int i = 0; i < fieldsCount; i++) {
			int accessFlags = getU2(dis, "Access flags");
		/*  ACC_PUBLIC      0x0001 	Declared public; may be accessed from outside its package.
			ACC_PRIVATE     0x0002 	Declared private; accessible only within the defining class and other classes belonging to the same nest (ยง5.4.4).
			ACC_PROTECTED   0x0004 	Declared protected; may be accessed within subclasses.
			ACC_STATIC      0x0008 	Declared static.
			ACC_FINAL       0x0010 	Declared final; never directly assigned to after object construction (JLS ยง17.5).
			ACC_VOLATILE    0x0040 	Declared volatile; cannot be cached.
			ACC_TRANSIENT   0x0080 	Declared transient; not written or read by a persistent object manager.
			ACC_SYNTHETIC   0x1000 	Declared synthetic; not present in the source code.
			ACC_ENUM        0x4000 	Declared as an element of an enum.*/

			getU2(dis, "Name index", true);
			getU2(dis, "Descriptor index", true);
			int attributesCount = getU2(dis, "Attributes count");
			readAttributes(dis, attributesCount);
		}
	}

	/**
	 * <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.6">4.6. Methods</a>
	 */
	private void readMethods(DataInputStream dis, int methodsCount) throws IOException {
		for (int i = 0; i < methodsCount; i++) {
			int accessFlags = getU2(dis, "Access flags");
		/*  ACC_PUBLIC 	    0x0001 	Declared public; may be accessed from outside its package.
			ACC_PRIVATE     0x0002 	Declared private; accessible only within the defining class and other classes belonging to the same nest (ยง5.4.4).
			ACC_PROTECTED   0x0004 	Declared protected; may be accessed within subclasses.
			ACC_STATIC      0x0008 	Declared static.
			ACC_FINAL       0x0010 	Declared final; must not be overridden (ยง5.4.5).
			ACC_SYNCHRONIZED 0x0020 Declared synchronized; invocation is wrapped by a monitor use.
			ACC_BRIDGE      0x0040 	A bridge method, generated by the compiler.
			ACC_VARARGS     0x0080 	Declared with variable number of arguments.
			ACC_NATIVE      0x0100 	Declared native; implemented in a language other than the Java programming language.
			ACC_ABSTRACT    0x0400 	Declared abstract; no implementation is provided.
			ACC_STRICT      0x0800 	Declared strictfp; floating-point mode is FP-strict.
			ACC_SYNTHETIC   0x1000 	Declared synthetic; not present in the source code. */

			getU2(dis, "Name index", true);
			getU2(dis, "Descriptor index", true);
			int attributesCount = getU2(dis, "Attributes count");
			readAttributes(dis, attributesCount);
		}
	}

	/**
	 * <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7">4.7. Attributes</a>
	 */
	private void readAttributes(DataInputStream dis, int attributesCount) throws IOException {
		for (int i = 0; i < attributesCount; i++) {
			getU2(dis, "Name index", true);
			int attributeLength = getU4(dis);
			for (int j = 0; j < attributeLength; j++) {
				dis.readByte();
				count++;
			}
		}
	}

	public enum ConstantPool {

		CONSTANT_Utf8(1, 2),                //1  45.3	1.0.2
		CONSTANT_Integer(3, 4),             //3  45.3	1.0.2
		CONSTANT_Float(4, 4),               //4  45.3	1.0.2
		CONSTANT_Long(5, 8),                //5  45.3	1.0.2
		CONSTANT_Double(6, 8),              //6  45.3	1.0.2
		CONSTANT_Class(7, 2),               //7  45.3	1.0.2
		CONSTANT_String(8, 2),              //8  45.3	1.0.2
		CONSTANT_Fieldref(9, 4),            //9  45.3	1.0.2
		CONSTANT_Methodref(10, 4),          //10 45.3	1.0.2
		CONSTANT_InterfaceMethodref(11, 4), //11 45.3	1.0.2
		CONSTANT_NameAndType(12, 4),        //12 45.3	1.0.2
		CONSTANT_MethodHandle(15, 3),       //15 51.0	7
		CONSTANT_MethodType(16, 2),         //16 51.0	7
		CONSTANT_Dynamic(17, 4),            //17 55.0	11
		CONSTANT_InvokeDynamic(18, 4),      //18 51.0	7
		CONSTANT_Module(19, 2),             //19 53.0	9
		CONSTANT_Package(20, 2);            //20 53.0	9

		private final int tag;
		private final int length;

		ConstantPool(int tag, int length) {
			this.tag = tag;
			this.length = length;
		}

		boolean isTwoEntriesTakeUp() {
			return this == CONSTANT_Double | this == CONSTANT_Long;
		}

		static ConstantPool getConstant(int tag) {
			for (ConstantPool cp : values()) {
				if (cp.tag == tag) {
					return cp;
				}
			}
			throw new RuntimeException("Wrong constant tag : " + tag);
		}
	}

	/**
	 * <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.4">4.4. The Constant Pool</a>
	 */
	private void readConstantPool(DataInputStream dis, int constantPoolCount) throws IOException {
		for (int i = 1; i < constantPoolCount; i++) {
			ConstantPoolRecord cpr = getCPRecord(i, dis);
			constants.add(cpr);
			if (cpr.cp.isTwoEntriesTakeUp()) {
				constants.add(null);
				i++;
			}
		}
		for (int i = 0; i < constants.size(); i++) {
			ConstantPoolRecord cpr = constants.get(i);
			cpr.print(constants);
			if (cpr.cp.isTwoEntriesTakeUp()) {
				i++;
			}
		}
	}

	private ConstantPoolRecord getCPRecord(int idx, DataInputStream dis) throws IOException {
		int offset = count;
		int tag = dis.read();
		count++;
		ConstantPool cp = ConstantPool.getConstant(tag);

		return switch (cp) {
			case CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module, CONSTANT_Package -> {
				final int aShort = dis.readUnsignedShort();
				count += Short.BYTES;
				yield new ConstantPoolString(offset, idx, cp, aShort);
			}
			case CONSTANT_Fieldref, CONSTANT_Methodref, CONSTANT_InterfaceMethodref, CONSTANT_NameAndType -> {
				final int aShort = dis.readUnsignedShort();
				count += Short.BYTES;
				int bShort = dis.readUnsignedShort();
				count += Short.BYTES;
				yield new ConstantPoolMethodRef(offset, idx, cp, aShort, bShort);
			}
			case CONSTANT_Utf8 -> {
				final int length = dis.readUnsignedShort();
				count += Short.BYTES;
				count += length;
				yield new ConstantPoolUtf8Record(offset, idx, cp, new String(dis.readNBytes(length)));
			}
			case CONSTANT_MethodHandle -> {
				final int referenceKind = dis.read();
				count++;
				int bShort = dis.readUnsignedShort();
				count += Short.BYTES;
				yield new ConstantPoolMethodHandle(offset, idx, cp, referenceKind, bShort);
			}
			default -> {
				count += cp.length;
				dis.readNBytes(cp.length);
				yield new ConstantPoolDefault(offset, idx, cp);
			}
		};
	}

	private int getU2(DataInputStream dis, String title) throws IOException {
		return getU2(dis, title, false);
	}

	private int getU2(DataInputStream dis, String title, boolean addSymbolicName) throws IOException {
		String symbolic = "";
		int u2 = dis.readUnsignedShort();
		if (addSymbolicName) {
			if (u2 > 0) {
				symbolic = " " + constants.get(u2 - 1).getString(constants);
			} else {
				symbolic = "java/lang/Object";
			}
		}

		System.out.printf("%04X %s %02d%s\n", count, title, u2, symbolic);
		count += Short.BYTES;
		return u2;
	}

	private int getU4(DataInputStream dis) throws IOException {
		int u4 = dis.readInt();
		System.out.printf("%04X %s %02d\n", count, "Attribute length", u4);
		count += Integer.BYTES;
		return u4;
	}

	private static final class Magic {
		static byte[] bytes = {(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE};
		static final int BYTES = bytes.length;

		private static void getMagic(DataInputStream dis) throws IOException {
			byte[] magic = dis.readNBytes(Magic.BYTES);
			if (!Arrays.equals(magic, Magic.bytes)) {
				StringBuilder sb = new StringBuilder();
				for (byte b : magic) {
					sb.append(String.format("%02X ", b));
				}
				throw new RuntimeException("Wrong magic tag : " + sb);
			}
		}
	}

	private static abstract class ConstantPoolRecord {
		int offset;
		int idx;
		ConstantPool cp;

		public ConstantPoolRecord(int offset, int idx, ConstantPool cp) {
			this.offset = offset;
			this.idx = idx;
			this.cp = cp;
		}

		void print(List<ConstantPoolRecord> constants) {
			System.out.printf("%04X %4d %19s ", offset, idx, cp.name().replaceFirst("^CONSTANT_", ""));
		}

		abstract String getString(List<ConstantPoolRecord> constants);
	}

	private static final class ConstantPoolString extends ConstantPoolRecord {
		int stringIndex;

		public ConstantPoolString(int offset, int idx, ConstantPool cp, int stringIndex) {
			super(offset, idx, cp);
			this.stringIndex = stringIndex;
		}

		@Override
		void print(List<ConstantPoolRecord> constants) {
			super.print(constants);
			System.out.println(getString(constants));
		}

		@Override
		String getString(List<ConstantPoolRecord> constants) {
			return "(" + stringIndex + ") " + constants.get(stringIndex - 1).getString(constants);
		}
	}

	private static final class ConstantPoolMethodRef extends ConstantPoolRecord {
		int classIndex;
		int nameAndTypeIndex;

		public ConstantPoolMethodRef(int offset, int idx, ConstantPool cp, int classIndex, int nameAndTypeIndex) {
			super(offset, idx, cp);
			this.classIndex = classIndex;
			this.nameAndTypeIndex = nameAndTypeIndex;
		}

		@Override
		void print(List<ConstantPoolRecord> constants) {
			super.print(constants);
			System.out.println(getString(constants));
		}

		@Override
		String getString(List<ConstantPoolRecord> constants) {
			return "(" + classIndex + ") " + constants.get(classIndex - 1).getString(constants)
					+ " (" + nameAndTypeIndex + ") " + constants.get(nameAndTypeIndex - 1).getString(constants);
		}
	}

	private static final class ConstantPoolUtf8Record extends ConstantPoolRecord {
		String UTF8;

		public ConstantPoolUtf8Record(int offset, int idx, ConstantPool cp, String UTF8) {
			super(offset, idx, cp);
			this.UTF8 = UTF8;
		}

		@Override
		void print(List<ConstantPoolRecord> constants) {
			super.print(constants);
			System.out.println(getString(constants));
		}

		@Override
		String getString(List<ConstantPoolRecord> constants) {
			return UTF8;
		}
	}

	private static final class ConstantPoolDefault extends ConstantPoolRecord {

		public ConstantPoolDefault(int offset, int idx, ConstantPool cp) {
			super(offset, idx, cp);
		}

		@Override
		void print(List<ConstantPoolRecord> constants) {
			super.print(constants);
			System.out.println(getString(constants));
		}

		@Override
		String getString(List<ConstantPoolRecord> constants) {
			return "" + cp.length;
		}
	}

	private static class ConstantPoolMethodHandle extends ConstantPoolRecord {
		private final int referenceKind;
		private final int referenceIndex;

		public ConstantPoolMethodHandle(int offset, int idx, ConstantPool cp, int referenceKind, int referenceIndex) {
			super(offset, idx, cp);
			this.referenceKind = referenceKind;
			this.referenceIndex = referenceIndex;
		}

		@Override
		void print(List<ConstantPoolRecord> constants) {
			super.print(constants);
			System.out.println(getString(constants));
		}

		@Override
		String getString(List<ConstantPoolRecord> constants) {
			return referenceKind + " (" + referenceIndex + ")" + constants.get(referenceIndex - 1).getString(constants);
		}
	}
}
